{
  "testName": "Переменные в Java",
  "questions": [
    {
      "text": "Что такое переменная в Java?",
      "detailedText": "Переменная в Java — это именованный контейнер для хранения данных определённого типа, который можно изменять во время выполнения программы.",
      "answers": [
        {"text": "Метод, выполняющий определённую операцию", "correct": false, "order": 1},
        {"text": "Контейнер для хранения данных определённого типа", "correct": true, "order": 2},
        {"text": "Специальный оператор", "correct": false, "order": 3},
        {"text": "Функция, вызываемая при запуске программы", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Какие бывают типы переменных в Java?",
      "detailedText": "В Java переменные бывают:\n\nЛокальные (объявлены внутри метода, недоступны за его пределами),\nЭкземпляра (связываются с объектом класса),\nКлассовые (статические) (относятся к классу, а не к объекту).",
      "answers": [
        {"text": "Локальные, глобальные, статические", "correct": false, "order": 1},
        {"text": "Локальные, экземпляра, классовые (статические)", "correct": true, "order": 2},
        {"text": "Приватные, защищённые, публичные", "correct": false, "order": 3},
        {"text": "Локальные, динамические, статические", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Как объявить переменную в Java?",
      "detailedText": "В Java переменная объявляется указанием типа, имени и (опционально) значением: int x = 10;.",
      "answers": [
        {"text": "var x;", "correct": false, "order": 1},
        {"text": "int x = 10;", "correct": true, "order": 2},
        {"text": "x = 10;", "correct": false, "order": 3},
        {"text": "declare int x = 10;", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Можно ли изменить значение final переменной?",
      "detailedText": "Ключевое слово final делает переменную неизменяемой — её значение нельзя изменять после присвоения.",
      "answers": [
        {"text": "Да, в любом случае", "correct": false, "order": 1},
        {"text": "Нет, после присвоения изменить нельзя", "correct": true, "order": 2},
        {"text": "Только если изменить тип", "correct": false, "order": 3},
        {"text": "Да, но только внутри метода", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Что произойдет, если попытаться использовать неинициализированную локальную переменную?",
      "detailedText": "Локальные переменные в Java должны быть явно инициализированы перед использованием, иначе компилятор выдаст ошибку.",
      "answers": [
        {"text": "Программа завершится без ошибок", "correct": false, "order": 1},
        {"text": "Значение переменной будет null", "correct": false, "order": 2},
        {"text": "Будет ошибка компиляции", "correct": true, "order": 3},
        {"text": "Java автоматически присвоит 0", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Какой модификатор доступа можно использовать для локальных переменных?",
      "detailedText": "Локальные переменные не могут иметь модификаторы доступа (public, private, protected), так как они существуют только в пределах метода.",
      "answers": [
        {"text": "public", "correct": false, "order": 1},
        {"text": "private", "correct": false, "order": 2},
        {"text": "protected", "correct": false, "order": 3},
        {"text": "Никакой", "correct": true, "order": 4}
      ]
    },
    {
      "text": "Как объявить константу в Java?",
      "detailedText": "В Java для объявления констант используется final. Если константа должна принадлежать классу, её объявляют static final.",
      "answers": [
        {"text": "const int MAX = 100;", "correct": false, "order": 1},
        {"text": "final int MAX = 100;", "correct": true, "order": 2},
        {"text": "static const int MAX = 100;", "correct": false, "order": 3},
        {"text": "var MAX = 100;", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Чем отличается переменная экземпляра от статической переменной?",
      "detailedText": "Переменные экземпляра создаются при создании объекта, а статические переменные принадлежат классу и существуют независимо от объектов.",
      "answers": [
        {"text": "Переменная экземпляра принадлежит объекту, а статическая – классу", "correct": true, "order": 1},
        {"text": "Статическая переменная создаётся внутри метода", "correct": false, "order": 2},
        {"text": "Статическая переменная не требует явного объявления", "correct": false, "order": 3},
        {"text": "Разницы нет", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Что произойдет, если объявить две переменные с одинаковым именем в одном методе?",
      "detailedText": "В одной области видимости нельзя объявить две переменные с одинаковым именем.",
      "answers": [
        {"text": "Будет ошибка компиляции", "correct": true, "order": 1},
        {"text": "Java выберет последнюю объявленную переменную", "correct": false, "order": 2},
        {"text": "Java выдаст предупреждение, но продолжит работу", "correct": false, "order": 3},
        {"text": "Переменные объединятся", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Можно ли использовать var для полей класса?",
      "detailedText": "var в Java используется только для локальных переменных и не может применяться к полям класса.",
      "answers": [
        {"text": "Да, в любом случае", "correct": false, "order": 1},
        {"text": "Нет, var можно использовать только для локальных переменных", "correct": true, "order": 2},
        {"text": "Только с static", "correct": false, "order": 3},
        {"text": "Только если поле final", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Чем отличается var от явного указания типа переменной?",
      "detailedText": "var в Java является механизмом выведения типов на этапе компиляции. Это не аналог dynamic из других языков — тип всё равно остаётся строгим и неизменным.",
      "answers": [
        {"text": "var работает быстрее", "correct": false, "order": 1},
        {"text": "var можно использовать только с final переменными", "correct": false, "order": 2},
        {"text": "var позволяет избежать явного указания типа, но тип определяется во время компиляции", "correct": true, "order": 3},
        {"text": "var делает переменную динамической", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Как работает shadowing (затенение) переменных в Java?",
      "detailedText": "Если в методе объявить переменную с таким же именем, как у переменной экземпляра, она затеняет поле класса. Для доступа к полю используют this.varName.",
      "answers": [
        {"text": "Позволяет двум переменным с одинаковым именем существовать одновременно", "correct": false, "order": 1},
        {"text": "Локальная переменная перекрывает переменную экземпляра или класса с тем же именем", "correct": true, "order": 2},
        {"text": "Позволяет менять тип переменной в рантайме", "correct": false, "order": 3},
        {"text": "Используется только в статических методах", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Где хранятся примитивные и ссылочные типы данных в памяти?",
      "detailedText": "В Java примитивные типы (например, int, double) хранятся в стеке, а объекты (String, List<>) создаются в куче, а ссылки на них хранятся в стеке.",
      "answers": [
        {"text": "Примитивные – в стеке, объекты – в куче", "correct": true, "order": 1},
        {"text": "Всё хранится в куче", "correct": false, "order": 2},
        {"text": "Примитивные и объекты всегда в стеке", "correct": false, "order": 3},
        {"text": "Размещение данных зависит от размера объекта", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Что происходит при присваивании одной переменной другой для примитивных и ссылочных типов?",
      "detailedText": "Присваивание переменной примитивного типа создаёт копию значения, а для ссылочного типа копируется ссылка на объект, а не сам объект.",
      "answers": [
        {"text": "В обоих случаях копируется значение", "correct": false, "order": 1},
        {"text": "Для примитивных типов копируется значение, а для ссылочных – ссылка на объект", "correct": true, "order": 2},
        {"text": "Java создаёт новый объект в куче", "correct": false, "order": 3},
        {"text": "Происходит глубокое копирование", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Как создать неизменяемый объект в Java?",
      "detailedText": "Для неизменяемости объекта нужно:\n\nСделать класс final, чтобы нельзя было его расширять\nОбъявить поля private final\nНе предоставлять сеттеры\nПри возврате объектов внутри класса использовать копии",
      "answers": [
        {"text": "Использовать final для всех полей", "correct": false, "order": 1},
        {"text": "Сделать класс final", "correct": false, "order": 2},
        {"text": "Сделать все поля private final, не предоставлять сеттеры и не возвращать изменяемые ссылки", "correct": true, "order": 3},
        {"text": "Все вышеперечисленные", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Можно ли изменить объект, если переменная объявлена как final?",
      "detailedText": "final означает, что сама переменная (ссылка) неизменяема, но объект, на который она ссылается, может изменяться.",
      "answers": [
        {"text": "Нет, объект становится неизменяемым", "correct": false, "order": 1},
        {"text": "Да, если это изменяемый объект (например, List или Map)", "correct": true, "order": 2},
        {"text": "Только через рефлексию", "correct": false, "order": 3},
        {"text": "Только если объект Serializable", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Почему нельзя использовать static внутри нестатических методов?",
      "detailedText": "Нестатические методы работают с экземплярами объектов, а static относится ко всему классу, поэтому их нельзя смешивать.",
      "answers": [
        {"text": "Нестатический метод относится к объекту, а static — к классу", "correct": true, "order": 1},
        {"text": "Это возможно", "correct": false, "order": 2},
        {"text": "Нестатический метод компилируется позже, чем static", "correct": false, "order": 3},
        {"text": "Java не поддерживает static в методах", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Можно ли объявить static переменную внутри метода?",
      "detailedText": "static переменные принадлежат классу и существуют на протяжении всего времени работы программы. Локальные переменные создаются и удаляются при вызове метода, поэтому static в методе использовать нельзя.",
      "answers": [
        {"text": "Да", "correct": false, "order": 1},
        {"text": "Нет", "correct": true, "order": 2},
        {"text": "Только в main()", "correct": false, "order": 3},
        {"text": "Только внутри synchronized метода", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Как правильно хранить null-чувствительные переменные?",
      "detailedText": "Для безопасной работы с null используют Optional<T>, проверки if (obj != null), Objects.requireNonNull() и аннотации @NonNull.",
      "answers": [
        {"text": "Всегда проверять null перед использованием", "correct": false, "order": 1},
        {"text": "Использовать Optional<T>", "correct": false, "order": 2},
        {"text": "Использовать Objects.requireNonNull()", "correct": false, "order": 3},
        {"text": "Все выше", "correct": true, "order": 4}
      ]
    },
    {
      "text": "Какое значение имеет static final переменная в классе?",
      "detailedText": "static final переменная создаётся один раз и не может быть изменена.",
      "answers": [
        {"text": "Создаётся один раз при загрузке класса", "correct": true, "order": 1},
        {"text": "Создаётся при каждом создании объекта", "correct": false, "order": 2},
        {"text": "Может изменяться в static методах", "correct": false, "order": 3},
        {"text": "Не может быть инициализирована в static блоке", "correct": false, "order": 4}
      ]
    },
    {
      "text": "В каких случаях final переменная может быть неинициализированной при объявлении?",
      "detailedText": "Для полей экземпляра final можно не инициализировать сразу, если значение устанавливается в каждом конструкторе.",
      "answers": [
        {"text": "Если это поле экземпляра, но инициализируется в конструкторе", "correct": true, "order": 1},
        {"text": "Если это static final переменная", "correct": false, "order": 2},
        {"text": "Если используется в if", "correct": false, "order": 3},
        {"text": "Никогда", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Как сделать объект неизменяемым, если он содержит изменяемые поля?",
      "detailedText": "Чтобы объект стал неизменяемым, даже если он содержит изменяемые поля (например, List), в геттерах следует использовать глубокое копирование (deep copy).",
      "answers": [
        {"text": "Сделать все поля final", "correct": false, "order": 1},
        {"text": "Использовать глубокое копирование в геттерах", "correct": true, "order": 2},
        {"text": "Заменить изменяемые поля на неизменяемые типы", "correct": false, "order": 3},
        {"text": "Нельзя создать неизменяемый объект с изменяемыми полями", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Как правильно объявить переменную ThreadLocal?",
      "detailedText": "ThreadLocal предоставляет каждому потоку отдельную копию переменной. Для правильной инициализации лучше использовать метод ThreadLocal.withInitial(), который задаёт начальное значение для каждого потока.",
      "answers": [
        {"text": "private ThreadLocal<Integer> value = new ThreadLocal<>();", "correct": false, "order": 1},
        {"text": "private static final ThreadLocal<Integer> value = ThreadLocal.withInitial(() -> 0);", "correct": true, "order": 2},
        {"text": "private static final ThreadLocal<Integer> value = new ThreadLocal<Integer>(0);", "correct": false, "order": 3},
        {"text": "ThreadLocal<Integer> value = 0;", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Чем отличается volatile от synchronized?",
      "detailedText": "Ключевое различие между volatile и synchronized заключается в их назначении. volatile гарантирует, что все потоки видят актуальное значение переменной, предотвращая её кеширование в отдельных потоках. synchronized используется для синхронизации доступа к блоку кода или методу, блокируя доступ к разделяемым данным для других потоков.",
      "answers": [
        {"text": "volatile синхронизирует потоки, а synchronized — нет", "correct": false, "order": 1},
        {"text": "volatile предотвращает кеширование переменной, а synchronized блокирует доступ к методу или блоку кода", "correct": true, "order": 2},
        {"text": "volatile блокирует доступ к методу, а synchronized предотвращает кеширование переменной", "correct": false, "order": 3},
        {"text": "Оба синхронизируют работу с многопоточностью, но volatile работает только для примитивов", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Что делает SoftReference<T> в Java?",
      "detailedText": "SoftReference<T> используется для реализации слабых ссылок, которые позволяют сборщику мусора удалять объект, на который существует только слабая ссылка, если в системе не хватает памяти.",
      "answers": [
        {"text": "Превращает объект в слабую ссылку, которая может быть собрана сборщиком мусора при нехватке памяти", "correct": true, "order": 1},
        {"text": "Делает объект доступным для изменения только в одном потоке", "correct": false, "order": 2},
        {"text": "Превращает объект в объект с возможностью его восстановления после сборки мусора", "correct": false, "order": 3},
        {"text": "Устанавливает объект как доступный для сборщика мусора только после выполнения всех операций с ним", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Как работает WeakReference<T> в Java?",
      "detailedText": "WeakReference<T> создаёт слабую ссылку на объект, которая не препятствует его удалению сборщиком мусора. Объект, на который указывает слабая ссылка, может быть собран даже в том случае, если эта ссылка ещё существует.",
      "answers": [
        {"text": "Подобно SoftReference, но объект может быть удалён сборщиком мусора даже при наличии слабой ссылки", "correct": true, "order": 1},
        {"text": "Всегда удерживает объект в памяти, пока существует хотя бы одна ссылка на него", "correct": false, "order": 2},
        {"text": "Не влияет на объект, он остаётся доступным даже после удаления ссылки", "correct": false, "order": 3},
        {"text": "Используется для управления жизненным циклом объектов, когда нужно предотвратить утечку памяти", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Что такое AtomicInteger и как его использовать?",
      "detailedText": "AtomicInteger позволяет безопасно изменять целочисленные значения в многопоточном приложении, обеспечивая атомарность операций без использования синхронизации.",
      "answers": [
        {"text": "Это тип данных для хранения больших чисел, доступный только для чтения", "correct": false, "order": 1},
        {"text": "Это класс для атомарных операций с целочисленными значениями в многопоточной среде", "correct": true, "order": 2},
        {"text": "Это класс, который выполняет операции с числами без использования блокировок", "correct": false, "order": 3},
        {"text": "Это класс для безопасного доступа к примитивам в многопоточной среде", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Что такое finalize() в Java и когда он вызывается?",
      "detailedText": "Метод finalize() вызывается объектом перед его уничтожением сборщиком мусора, что позволяет выполнить дополнительные действия, такие как освобождение ресурсов.",
      "answers": [
        {"text": "Это метод, который вызывается, когда объект теряет ссылку на себя", "correct": false, "order": 1},
        {"text": "Это метод, который вызывается перед удалением объекта сборщиком мусора", "correct": true, "order": 2},
        {"text": "Это метод, который вызывается для объектов, не участвующих в сборке мусора", "correct": false, "order": 3},
        {"text": "Это метод, который можно использовать для создания новых объектов после их удаления", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Какой тип данных используется для представления строк в Java?",
      "detailedText": "В Java строки представлены типом данных String, который является неизменяемым (immutable).",
      "answers": [
        {"text": "char[]", "correct": false, "order": 1},
        {"text": "StringBuilder", "correct": false, "order": 2},
        {"text": "String", "correct": true, "order": 3},
        {"text": "char", "correct": false, "order": 4}
      ]
    },
    {
      "text": "Как объявить массив строк и инициализировать его значениями при создании?",
      "detailedText": "Этот способ объявления массива строк с его инициализацией является стандартным и правильным в Java.",
      "answers": [
        {"text": "String[] arr = {\"Java\", \"Python\", \"C++\"};", "correct": true, "order": 1},
        {"text": "String arr = new String[]{\"Java\", \"Python\", \"C++\"};", "correct": false, "order": 2},
        {"text": "String[] arr = new String[](\"Java\", \"Python\", \"C++\");", "correct": false, "order": 3},
        {"text": "String[] arr = {\"Java\", new String(\"Python\"), \"C++\"};", "correct": false, "order": 4}
      ]
    }
  ]
}